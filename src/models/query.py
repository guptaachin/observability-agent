"""
Data models for natural language metric queries.

This module defines the validated query parameter structures used by the
natural language metrics agent. All models use Pydantic for validation,
ensuring data integrity before passing to the MCP server.
"""

from datetime import datetime
from typing import Dict, Optional

from pydantic import BaseModel, Field, field_validator


class TimeRange(BaseModel):
    """
    Time range specification for metric queries.
    
    Represents the start and end times for a metric query. Validates that
    end_time is after start_time to prevent invalid query parameters.
    
    Attributes:
        start_time: Query start time (ISO 8601 format)
        end_time: Query end time (ISO 8601 format)
    
    Example:
        >>> from datetime import datetime, timedelta
        >>> now = datetime.now()
        >>> tr = TimeRange(
        ...     start_time=now - timedelta(hours=1),
        ...     end_time=now
        ... )
        >>> tr.start_time < tr.end_time
        True
    """
    
    start_time: datetime = Field(
        description="Query start time (ISO 8601 format)"
    )
    end_time: datetime = Field(
        description="Query end time (ISO 8601 format)"
    )
    
    @field_validator('end_time')
    @classmethod
    def end_after_start(cls, v: datetime, info):
        """Validate that end_time is after start_time."""
        if 'start_time' in info.data and v <= info.data['start_time']:
            raise ValueError("end_time must be after start_time")
        return v


class MetricsQuery(BaseModel):
    """
    Parsed natural language metric query with validated parameters.
    
    Represents a user's natural language question parsed into structured
    parameters suitable for Grafana queries. Generated by the LLM from the
    user's natural language input and validated before execution.
    
    This model serves as the bridge between natural language understanding
    and structured metric querying. The LLM produces MetricsQuery JSON, which
    Pydantic validates before passing to the Grafana MCP client.
    
    Attributes:
        metric_name: Name of the metric to query
        time_range: Time range for the query
        aggregation: Optional aggregation function (avg, max, min, sum)
        filters: Optional metric filters
        confidence: LLM confidence in this interpretation (0.0-1.0)
    
    Example:
        >>> from datetime import datetime, timedelta
        >>> query = MetricsQuery(
        ...     metric_name="cpu_usage",
        ...     time_range=TimeRange(
        ...         start_time=datetime(2026, 1, 21, 10, 0, 0),
        ...         end_time=datetime(2026, 1, 21, 11, 0, 0)
        ...     ),
        ...     aggregation="avg"
        ... )
        >>> query.metric_name
        'cpu_usage'
    """
    
    # Primary identifiers
    metric_name: str = Field(
        description="Name of the metric to query (e.g., 'cpu_usage', 'memory_utilization')"
    )
    
    # Time range
    time_range: TimeRange = Field(
        description="Query time range (start_time, end_time)"
    )
    
    # Optional parameters
    aggregation: Optional[str] = Field(
        default=None,
        description="Optional aggregation function: 'avg', 'max', 'min', 'sum'"
    )
    
    filters: Optional[Dict[str, str]] = Field(
        default=None,
        description="Optional filters (e.g., {'instance': 'server-1', 'region': 'us-east'})"
    )
    
    # Metadata
    confidence: float = Field(
        default=1.0,
        description="LLM confidence in this interpretation (0.0-1.0)"
    )
    
    @field_validator('aggregation')
    @classmethod
    def validate_aggregation(cls, v: Optional[str]) -> Optional[str]:
        """Ensure aggregation is one of allowed values."""
        if v and v not in ['avg', 'max', 'min', 'sum']:
            raise ValueError(
                f"Invalid aggregation: {v}. Must be one of: avg, max, min, sum"
            )
        return v
    
    @field_validator('confidence')
    @classmethod
    def validate_confidence(cls, v: float) -> float:
        """Ensure confidence is between 0.0 and 1.0."""
        if not (0.0 <= v <= 1.0):
            raise ValueError(f"Confidence must be between 0.0 and 1.0, got {v}")
        return v
    
    def to_mcp_request(self) -> dict:
        """
        Format this query as a request for the Grafana MCP server.
        
        Converts the MetricsQuery into the dictionary format expected by the
        Grafana MCP server's query_grafana_metrics tool. This method handles
        the translation from our internal model to the MCP server's interface.
        
        Returns:
            Dictionary with keys:
                - metric_name: str - Name of metric to query
                - start_time: str - ISO 8601 start timestamp
                - end_time: str - ISO 8601 end timestamp
                - aggregation: str or null - Aggregation function
                - filters: dict or null - Metric filters
        
        Example:
            >>> from datetime import datetime
            >>> query = MetricsQuery(
            ...     metric_name="cpu_usage",
            ...     time_range=TimeRange(
            ...         start_time=datetime(2026, 1, 21, 10, 0, 0),
            ...         end_time=datetime(2026, 1, 21, 11, 0, 0)
            ...     )
            ... )
            >>> request = query.to_mcp_request()
            >>> request['metric_name']
            'cpu_usage'
            >>> isinstance(request['start_time'], str)
            True
        """
        return {
            "metric_name": self.metric_name,
            "start_time": self.time_range.start_time.isoformat(),
            "end_time": self.time_range.end_time.isoformat(),
            "aggregation": self.aggregation,
            "filters": self.filters
        }
    
    model_config = {
        "json_schema_extra": {
            "examples": [
                {
                    "metric_name": "cpu_usage",
                    "time_range": {
                        "start_time": "2026-01-21T10:00:00",
                        "end_time": "2026-01-21T11:00:00"
                    }
                },
                {
                    "metric_name": "memory_utilization",
                    "time_range": {
                        "start_time": "2026-01-20T00:00:00",
                        "end_time": "2026-01-21T00:00:00"
                    },
                    "aggregation": "avg",
                    "filters": {"instance": "prod-server-1"}
                }
            ]
        }
    }
