# Data Model: Grafana Dashboard Agent

**Phase**: 1 (Design & Contracts)  
**Date**: 2026-01-23  
**Status**: Complete  
**Purpose**: Define core entities, their attributes, relationships, and state transitions.

---

## Core Entities

### 1. Dashboard

**Purpose**: Represents a Grafana dashboard that the agent can list and describe.

**Attributes**:
- `id` (int): Unique Grafana dashboard ID
- `uid` (str): Dashboard unique identifier (human-readable slug)
- `title` (str): Dashboard display name
- `description` (str, optional): Dashboard description
- `tags` (list[str], optional): Dashboard tags (e.g., ["prod", "metrics"])
- `url` (str): Dashboard URL path (e.g., "/d/abc123/my-dashboard")
- `updated` (datetime): Last update timestamp
- `folder_id` (int, optional): Parent folder ID if organized in folders

**Example**:
```json
{
  "id": 1,
  "uid": "abc123def456",
  "title": "System Metrics",
  "description": "CPU, memory, disk usage across production servers",
  "tags": ["prod", "infrastructure"],
  "url": "/d/abc123def456/system-metrics",
  "updated": "2026-01-23T14:30:00Z",
  "folder_id": 5
}
```

**Source**: Fetched from Grafana MCP tool's `list_dashboards` action; filtered by org_id.

**Validation**:
- `id` must be positive integer
- `title` must be non-empty string
- `tags` list must not exceed 10 items (practical limit)

**Cardinality**: Multiple dashboards per Grafana instance; returned as list to user.

---

### 2. Query

**Purpose**: Represents a user's natural language question and the agent's interpretation of it.

**Attributes**:
- `text` (str): Original user input (e.g., "Show me all dashboards")
- `intent` (str): Interpreted intent (e.g., "list_all_dashboards" or "get_specific_dashboard")
- `scope` (str): Scope classification—one of:
  - `"all_dashboards"`: User wants complete dashboard list
  - `"search_dashboards"`: User asks for dashboards matching criteria (not yet supported; out-of-scope)
  - `"get_specific"`: User asks for one dashboard by name (not yet supported; out-of-scope)
  - `"unsupported"`: Query is outside agent capability (metrics, anomalies, recommendations)
- `filters` (dict, optional): Extracted filters from query (e.g., `{"tag": "prod"}` from "Show me dashboards with tag prod")
- `is_valid` (bool): True if intent matches supported scope; False if unsupported

**Example**:
```json
{
  "text": "Show me all dashboards",
  "intent": "list_all_dashboards",
  "scope": "all_dashboards",
  "filters": {},
  "is_valid": true
}
```

**Example (Out-of-Scope)**:
```json
{
  "text": "What's the CPU usage trend?",
  "intent": "query_metrics",
  "scope": "unsupported",
  "filters": {"metric": "cpu_usage"},
  "is_valid": false
}
```

**Processing**: Generated by LLM in agent node based on system prompt guidance.

**Validation**:
- `text` must be non-empty and ≤500 characters (practical UI limit)
- `intent` must match recognized patterns (hardcoded in prompt)
- `scope` must be one of the four values above
- If `is_valid=false`, agent returns error message instead of querying Grafana

---

### 3. AgentMessage (State)

**Purpose**: Represents the agent's state during a single interaction (query → processing → response).

**Attributes**:
- `query_text` (str): User's natural language input
- `parsed_query` (Query): Parsed and classified user intent
- `dashboards` (list[Dashboard], optional): Results from Grafana if valid query
- `error_message` (str, optional): Human-readable error if query is invalid or Grafana unreachable
- `processing_metadata` (dict): Logging/observability info
  - `llm_model` (str): Which LLM was used (e.g., "gpt-4", "ollama/mistral")
  - `response_time_ms` (int): Total processing time
  - `mcp_server_reachable` (bool): True if Grafana MCP server is available

**Example (Success)**:
```json
{
  "query_text": "Show me all dashboards",
  "parsed_query": {
    "text": "Show me all dashboards",
    "intent": "list_all_dashboards",
    "scope": "all_dashboards",
    "filters": {},
    "is_valid": true
  },
  "dashboards": [
    {
      "id": 1,
      "title": "System Metrics",
      "tags": ["prod"],
      "updated": "2026-01-23T14:30:00Z"
    },
    {
      "id": 2,
      "title": "Application Logs",
      "tags": ["prod", "app"],
      "updated": "2026-01-23T12:00:00Z"
    }
  ],
  "error_message": null,
  "processing_metadata": {
    "llm_model": "gpt-4",
    "response_time_ms": 1240,
    "mcp_server_reachable": true
  }
}
```

**Example (Error)**:
```json
{
  "query_text": "What's the CPU trend?",
  "parsed_query": {
    "text": "What's the CPU trend?",
    "intent": "query_metrics",
    "scope": "unsupported",
    "filters": {"metric": "cpu"},
    "is_valid": false
  },
  "dashboards": null,
  "error_message": "I can list dashboards, but metrics queries are not yet supported. Please use the Grafana UI or Prometheus API directly.",
  "processing_metadata": {
    "llm_model": "gpt-4",
    "response_time_ms": 840,
    "mcp_server_reachable": true
  }
}
```

**Lifecycle**:
1. **Initialized**: User submits query_text via Gradio
2. **Parsed**: LLM classifies query → parsed_query populated
3. **Executed**: If valid, MCP tool invoked → dashboards populated
4. **Finalized**: Response formatted and returned to user

**Cardinality**: One AgentMessage per user interaction; messages are not persisted between sessions (per Principle II: No memory).

---

## Relationships

```
User Input (text)
    ↓
LLM (interpret intent)
    ↓
Query (parsed classification)
    ↓
Decision Point:
    ├─ if valid=true → MCP Tool (Grafana API)
    │   ↓
    │   Dashboards (results)
    │   ↓
    │   Format for display
    └─ if valid=false → Error Message
        ↓
        Format error response
```

---

## State Transitions

```
START
  ↓
query_text received
  ↓
LLM processes (classification)
  ↓
Is intent valid?
  ├─ YES → Call Grafana MCP
  │         ↓
  │         Dashboards retrieved
  │         ↓
  │         Format success response
  │         ↓
  │         END
  │
  └─ NO → Return error message
           ↓
           END
```

---

## Validation Rules

| Entity | Field | Rule | Reason |
|--------|-------|------|--------|
| Dashboard | id | positive integer | Grafana requirement |
| Dashboard | title | non-empty string | Display requirement |
| Dashboard | tags | max 10 items | Practical performance |
| Query | text | non-empty, ≤500 chars | UI usability |
| Query | scope | one of 4 values | Bounded scope per spec |
| Query | is_valid | boolean | Routing logic |
| AgentMessage | dashboards | list[Dashboard] or null | Conditional on query validity |
| AgentMessage | error_message | string or null | Mutually exclusive with dashboards |

---

## Serialization & Type Definitions

**Python (pydantic models)**:

```python
from pydantic import BaseModel, Field, field_validator
from datetime import datetime
from typing import Optional, List, Dict

class Dashboard(BaseModel):
    id: int = Field(..., gt=0)
    uid: str
    title: str = Field(..., min_length=1)
    description: Optional[str] = None
    tags: List[str] = Field(default_factory=list, max_length=10)
    url: str
    updated: datetime
    folder_id: Optional[int] = None

class Query(BaseModel):
    text: str = Field(..., min_length=1, max_length=500)
    intent: str
    scope: str = Field(..., pattern="^(all_dashboards|search_dashboards|get_specific|unsupported)$")
    filters: Dict[str, str] = Field(default_factory=dict)
    is_valid: bool

class ProcessingMetadata(BaseModel):
    llm_model: str
    response_time_ms: int
    mcp_server_reachable: bool

class AgentMessage(BaseModel):
    query_text: str
    parsed_query: Query
    dashboards: Optional[List[Dashboard]] = None
    error_message: Optional[str] = None
    processing_metadata: ProcessingMetadata
    
    @field_validator("dashboards", "error_message")
    @classmethod
    def validate_mutual_exclusivity(cls, v, info):
        """Ensure dashboards XOR error_message, not both."""
        data = info.data
        if data.get("dashboards") and data.get("error_message"):
            raise ValueError("Cannot have both dashboards and error_message")
        if not data.get("dashboards") and not data.get("error_message"):
            raise ValueError("Must have either dashboards or error_message")
        return v
```

---

## JSON Schema (for configuration & API contracts)

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Agent Message",
  "type": "object",
  "properties": {
    "query_text": {
      "type": "string",
      "minLength": 1,
      "maxLength": 500
    },
    "parsed_query": {
      "type": "object",
      "properties": {
        "text": { "type": "string" },
        "intent": { "type": "string" },
        "scope": { "enum": ["all_dashboards", "search_dashboards", "get_specific", "unsupported"] },
        "filters": { "type": "object" },
        "is_valid": { "type": "boolean" }
      },
      "required": ["text", "intent", "scope", "is_valid"]
    },
    "dashboards": {
      "type": "array",
      "items": {
        "type": "object",
        "properties": {
          "id": { "type": "integer", "minimum": 1 },
          "title": { "type": "string", "minLength": 1 },
          "tags": { "type": "array", "items": { "type": "string" }, "maxLength": 10 },
          "updated": { "type": "string", "format": "date-time" }
        }
      }
    },
    "error_message": { "type": ["string", "null"] },
    "processing_metadata": {
      "type": "object",
      "properties": {
        "llm_model": { "type": "string" },
        "response_time_ms": { "type": "integer", "minimum": 0 },
        "mcp_server_reachable": { "type": "boolean" }
      }
    }
  },
  "required": ["query_text", "parsed_query", "processing_metadata"]
}
```

---

## Notes for Implementation

1. **No Persistence**: AgentMessage is created, processed, and returned in a single request. It's not stored in a database (per Principle II: No memory).
2. **Statelessness**: Each interaction is independent. The agent doesn't reference previous queries or results.
3. **LangSmith Logging**: All attributes (especially processing_metadata) are captured in LangSmith for debugging and learning.
4. **Error Path**: When error_message is populated, dashboards must be None, and vice versa. Pydantic validation enforces this.
5. **Future Extensibility**: Query scope will expand (search_dashboards, get_specific) in Phase 2; data model is ready for these additions without refactoring.
